import { list_children, is_file, is_dir, mkdir_all_safe } from "lib/fs.js"
const { core, assert } = lo;
const { write_file, read_file, mkdir, S_IRWXU, S_IRWXG, S_IROTH } = core

const default_lib_dir_name = 'lib'
const api_file_name = 'api.js'

export const get_apis = (lib_dir = default_lib_dir_name) => {
  const filter_js_ts_files = (path = '') => path && !/\.[jt]s/.test(path)
  const modules_set = new Set()
  /**@type {LibApiMeta[]}*/
  const apis = []
  const add_api = (local = false, path = '') => {
    if (!is_file(`${path}/${api_file_name}`)) return
    const module_name = path.replace(/^.*\/([^\/]+)$/, '$1')
    if (modules_set.has(module_name)) return
    modules_set.add(module_name)
    apis.push({ module_name, path: `${path}/${api_file_name}`, local })
  }

  list_children(`${lo.getcwd()}/${lib_dir}`).filter(filter_js_ts_files)
    .forEach(add_api.bind(null, true))

  const home = lo.getenv('LO_HOME')
  if (home && home != lib_dir) list_children(`${home}/${default_lib_dir_name}`)
    .filter(filter_js_ts_files).forEach(add_api.bind(null, false))

  return apis
}

/**
 * @param {string} path
 * @returns {Promise<LibApiExports>}
 */
export const import_api_js_exports_typed = async (path) => await import(path)

/**
 * @param {LibApiMeta} x
* @returns {string}
*/
const get_api_js_module_declaration = ({ path, local }) => {
  const declare_module_path = path.replace(local ? lo.getcwd() : lo.getenv('LO_HOME'), '').replace(/^\//, '')
  return `declare module "${declare_module_path}" {
  export const name: string;
  export const api: LibApi;
  export const constants: LibConstants;
  export const mac: LibPlatform | void;
  export const win: LibPlatform | void;
  export const linux: LibPlatform | void;
  export const structs: string[] | void
  export const preamble: string | void;
  export const includes: string[] | void;
  export const obj: string[] | void;
}`
}

const get_autogenerated_globals = () => {
  const delimiter = '// ####### !!!DO NOT EDIT CODE BELOW THIS LINE! AUTOGENERATED!!! #######'
  const missing_globals = ['WebAssembly'].join('\n    // ')
  const omit_globals = global_this_base_omit_type().split('=')[1]
    .replace(/[ \n';]+/gm, '').split('|')
  const global_this_base_pick = `"${Object.getOwnPropertyNames(globalThis)
    .filter((s) => !missing_globals.includes(s) && !omit_globals.includes(s))
    .join(`"\n    | "`)}"`
  const autogenerated_str = `${delimiter}
// TODO: add lo.core.engine prop to determine engine
interface CurrentRuntimeGenerics extends RuntimeGenerics<'v8', '${lo.core.os}', '${lo.core.arch}'> {}
// global base type
// keep only things that we have, no need to confuse people
interface GlobalThisBase
  extends Omit<Pick<
    typeof globalThis,
    // list from: lo eval 'console.log(\`"\${Object.getOwnPropertyNames(globalThis).join(\`"    \\n| "\`)}"\`)'
    | ${global_this_base_pick}
    // missing typedefs (extract from typescript DOM lib, we don't need DOM messing with types):
    // WebAssembly issue - https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/826
    // ${missing_globals}
  >,
  GlobalThisBaseOmit
  > {}
`
  return autogenerated_str
}

/**@param {LibApiExports[]} lib_exports */
const get_native_libs_string = (lib_exports) => {
  let native_libs_str = ''
  for (let i = 0; i < lib_exports.length; i++) {
    const def = lib_exports[i]
    const platform = def[lo.core.os]
    const structs = [...def.structs || [], ...platform?.structs || []]
    const constants = { ...def.constants, ...platform?.constants }
    const api = { ...def.api, ...platform?.api }
    native_libs_str = `${native_libs_str}  ${def.name}: {
${Object.keys(api).map((k) => {
      let res = ''
      const api_k = api[k]
      if ('declare_only' in api_k) return res
      const { parameters, result, arch, jsdoc, man, optional } = api_k
      // arch is defined and doesn't match
      if (arch && arch.length && !arch.includes(lo.core.arch)) return res
      const parameters_strings = parameters.map((v, i) => `p${i}${optional?.[i] && '?' || ''}: ${
        paramsTypeMap[v] || (typeof v == 'number' ? v : 'number')}`)
      const jsdoc_str = `${jsdoc ? jsdoc +'\n' : ''}`
      const man_str = `${man ? `// man: ${man}\n` : ''}`
      const ret_str = paramsTypeMap[result] || 'number'

      res = `${jsdoc_str}${man_str}    ${k}(${parameters_strings}): ${ret_str};\n`
      return res;
    }).join('')}${Object.keys(constants).map(k => `    ${k}: number;\n`).join('')}${
      structs.map(s => `    ${s}: number;\n`).join('')}  };
`
  }

  return `interface NativeLibs {
${native_libs_str}  }`
}

const paramsTypeMap = {
  buffer: 'TypedArray',
  string: 'string',
  u32array: 'Uint32Array',
  bool: 'boolean | 1 | 0',
  void: 'void'
}

export const test = async () => {
  const apis = get_apis()
  const lib_exports = await Promise.all(apis.map(({ path }) => import_api_js_exports_typed(path)))

  console.log(`${lo_globalsdts_str()}

${get_autogenerated_globals()}
${get_native_libs_string(lib_exports)}
${apis.map(get_api_js_module_declaration).join('\n')}
`)
  // console.log(JSON.stringify(await import_api_exports(apis[0]), null, 2))
}


/**
* @typedef {{
*  path: string;
*  module_name: string;
*  local: boolean;
* }} LibApiMeta
*/

/**
* @typedef {{
*  name: string;
*  api: LibApi;
*  constants: LibConstants;
*  mac?: LibPlatform;
*  win?: LibPlatform;
*  linux?: LibPlatform;
*  structs?: string[]
*  preamble?: string;
*  includes?: string[];
*  obj?: string[];
* }} LibApiExports
*/

const native_lib_api_types = () => `// ############ NativeLib API stuff ##############
type LIB_API_ARCH = 'x64';
type LIB_API_C_TYPE = 'u64' | 'f64' | 'u32' | 'i64' | 'f32' | 'i32' | 'u8' | 'void' | 'char';
type LIB_API_POINTER = 'pointer'
type LIB_API_BOOL = 'bool';
type LIB_API_STRING = 'string';
type LIB_API_BUFFER = 'buffer';
type LIB_API_TYPED_ARRAY = 'u32array';

type LibApiParameter = LIB_API_POINTER | LIB_API_C_TYPE | LIB_API_STRING
  | LIB_API_BUFFER | LIB_API_TYPED_ARRAY | LIB_API_BOOL;
type LibApiResult = LIB_API_POINTER | LIB_API_C_TYPE | LIB_API_BOOL;
type LibApiPointer = string; // this is sad
type LibApiOverride = { param: number, fastfield: string, slowfield: string } | number;
type LibApiItem = { nofast: boolean; declare_only: boolean; } | {
  parameters: LibApiParameter[];
  optional?: (true | false | 1 | 0 | undefined)[];
  pointers?: (LibApiPointer | void)[];
  result: LibApiResult;
  rpointer?: LibApiPointer | [LibApiPointer];
  name?: string;
  arch?: ARCH[];
  override?: (LibApiOverride | void)[];
  casts?: (string | void)[];
  jsdoc?: string;
  man?: string[] | string;
  nofast?: boolean;
  nonblocking?: boolean;
};
type LibApi = Record<string, LibApiItem>;
type LibApiTypedFn = <const T extends LibApi>(api: T) => T;


type ConstantType = Omit<LIB_API_C_TYPE, 'void' | 'char'> | number;
type LibConstants = Record<string, ConstantType>;
type LibConstsTypedFn = <const T extends LibConstants>(constnats: T) => T;

type Platform = 'mac' | 'linux';
interface LibPlatform {
  name: string;
  api: LibApi;
  constants?: LibConstants;
  structs?: string[];
  includes?: string[];
  libs?: string[];
  externs?: string[];
  include_paths?: string[];
  lib_paths?: string[];
  obj?: string[];
  preamble?: string;
}
type LibPlatformTypedFn = <const T extends Partial<LibPlatform>>(platform: T) => T;
`

const lo_globalsdts_str = () => `
${wrap_typedef_block('lo_base_types', lo_base_types)}
${wrap_typedef_block('declared_global_types', declared_global_types)}
${wrap_typedef_block('global_this_type', global_this_type)}
${wrap_typedef_block('global_this_base_omit_type', global_this_base_omit_type)}
${wrap_typedef_block('native_lib_core_type', native_lib_core_type)}
${wrap_typedef_block('runtime_type', runtime_type)}
${wrap_typedef_block('text_encoder_types', text_encoder_types)}
${wrap_typedef_block('text_decoder_types', text_decoder_types)}
${wrap_typedef_block('iterator_types', iterator_types)}
${wrap_typedef_block('native_lib_api_types', native_lib_api_types)}
${wrap_typedef_block('native_lib_exports_types', native_lib_exports_types)}
`

const wrap_typedef_block = (name, fn) => `// ####### ${name} start #######
// please add final edits to ${name} in lib/types.js
${fn()}
// ####### ${name} end #######
`;

const lo_base_types = () => `/// <reference no-default-lib="true"/>
/// <reference lib="es2023"/>
// TODO: refine generic NativeLib* types for lib/<module>/api.js (platform)

// generic typedef helper for classes:
// interface IClassX { ... }
// declare var ClassX: Constructor<IClassX>
// TODO: find solution to class declaration issues (TS class declaration !== JS class declaration)
interface Constructor<T> {
  readonly prototype: T;
  new (): T;
}

type OnUnhandledRejection = (error: Error) => void;

type Require = <T extends Record<string | number | symbol, unknown>>(
  file_path: string
) => T | undefined;

interface Console {
  log: (str: unknown) => number;
  error: (str: unknown) => number;
}

// available globally with v8 --expose-gc flag
type GC = undefined | (() => void);

type ZeroOrMinusOne = 0 | -1;
type ENGINE = 'v8';
type OS = 'mac' | 'win' | 'linux';
type ARCH = 'x64' | 'arm64';
type TypedArray =
  | Uint8Array
  | Int8Array
  | Uint16Array
  | Int16Array
  | Uint32Array
  | Int32Array
  | Float32Array
  | Float64Array
  | BigUint64Array
  | BigInt64Array
  | ArrayBuffer;

type Ptr<T extends TypedArray> = T & {
  ptr: number;
  size: number;
};

type UnknownLib<T extends string | number> = Record<
  T | string | number | symbol,
  unknown
>;
type Library<T extends string | number> =
  (T extends NativeLibsKeys ? NativeLibXExport<T> : UnknownLib<T>)
    & {
      handle?: number;
      fileName?: string;
      internal?: boolean;
    };

interface RuntimeVersion {
  lo: string;
  v8: string;
}

interface RuntimeGenerics<E extends ENGINE, O extends OS, A extends ARCH> {
  engine: E;
  os: O;
  arch: A;
}
`

const text_encoder_types = () => `type TextEncoderConstructor = Constructor<ITextEncoder>;
interface ITextEncoder {
  /**
   * The encoding supported by the \`TextEncoder\` instance. Always set to \`'utf-8'\`.
   */
  readonly encoding: string;
  /**
   * UTF-8 encodes the \`input\` string and returns a \`Uint8Array\` containing the
   * encoded bytes.
   * @param [input='an empty string'] The text to encode.
   */
  encode(input?: string): Uint8Array;
  /**
   * UTF-8 encodes the \`src\` string to the \`dest\` Uint8Array and returns an object
   * containing the read Unicode code units and written UTF-8 bytes.
   *
   * \`\`\`js
   * const encoder = new TextEncoder();
   * const src = 'this is some data';
   * const dest = new Uint8Array(10);
   * const { read, written } = encoder.encodeInto(src, dest);
   * \`\`\`
   * @param src The text to encode.
   * @param dest The array to hold the encode result.
   */
  encodeInto(src?: string, dest?: Uint8Array): number;
}
`

const text_decoder_types = () => `type TextDecoderConstructor = Constructor<ITextDecoder>;
interface ITextDecoder {
  /**
   * The encoding supported by the \`TextEncoder\` instance. Always set to \`'utf-8'\`.
   */
  readonly encoding: string;
  /**
   * UTF-8 decodes the \`Uint8Array\` and returns an \`input\` string.
   */
  decode(ptr_source?: Ptr<Uint8Array> | Uint8Array): string;
}`

const iterator_types = () => `// Iterator class type from https://github.com/zloirock/core-js#iterator-helpers
interface IteratorConstructor extends Constructor<IIterator> {
  from(iterable: Iterable<any> | Iterator<any>): Iterator<any>;
}
type Uint = number;
interface IIterator {
  drop(limit: Uint): Iterator<any>;
  every(callbackfn: (value: any, counter: Uint) => boolean): boolean;
  filter(callbackfn: (value: any, counter: Uint) => boolean): Iterator<any>;
  find(callbackfn: (value: any, counter: Uint) => boolean): any;
  flatMap(callbackfn: (value: any, counter: Uint) => Iterable<any> | Iterator<any>): Iterator<any>;
  forEach(callbackfn: (value: any, counter: Uint) => void): void;
  map(callbackfn: (value: any, counter: Uint) => any): Iterator<any>;
  reduce(callbackfn: (memo: any, value: any, counter: Uint) => any, initialValue: any): any;
  some(callbackfn: (value: any, counter: Uint) => boolean): boolean;
  take(limit: Uint): Iterator<any>;
  toArray(): Array<any>;
}`

const declared_global_types = () => `declare var global: GlobalThis;
declare var onUnhandledRejection: OnUnhandledRejection;
declare var require: Require;
declare var TextEncoder: TextEncoderConstructor;
declare var TextDecoder: TextDecoderConstructor;
declare var lo: Runtime;
declare var gc: GC;
declare var Iterator: IteratorConstructor;
declare var console: Console;`

const global_this_base_omit_type = () => `// we define those manually:
type GlobalThisBaseOmit = ${declared_global_types()
  .replace(/^.+ var ([A-z]+): ([A-z]+;).*/gm, "--'$1'")
  .split('--')
  .join('  | ')
};
`
const global_this_type = () => `interface GlobalThis extends GlobalThisBase {
${declared_global_types()
    .replace(/^.+ var ([A-z]+): ([A-z]+;)/gm, "  $1:$2--")
    .split('--')
    .join('')
  }
}
`

const native_lib_core_type = () => `// lo.core = lo.load('core') + overrides listed here
type Core<T extends 'core' = 'core'> = Overwrite<NativeLibXExport<T>[T], {
  dlsym(handle: number, name: string): number;
  dlopen(path: string, flags: number): number;
  // strnlen(str: string | number, size: number): number;
  /**
   * Reads a file from the given path into a Uint8Array and returns it.
   * @param [path] The path to the file.
   */
  read_file(path: string): Uint8Array;
  /**
   * Creates/Overwrites a file at the specified path with the given Uint8Array
   * as the contents of the file.
   * @param {string}[path] The path of the file to create.
   * @param {TypedArray}[buffer] The data write to the file.
   * @returns {number} Number of bytes written
   */
  write_file(
    path: string,
    buffer: Uint8Array,
    flags?: number,
    mode?: number
  ): number;
  os: OS;
  arch: ARCH;
  engine: ENGINE;
  little_endian: boolean;
  homedir: string;
  defaultWriteFlags: number;
  defaultWriteMode: number;
  mmap(
    ptr: number,
    length: number,
    prot: number,
    flags: number,
    fd: number,
    offset: number,
    buf: Uint32Array
  ): void;
  getcwd(ptr: number, num: number, buf: Uint32Array): void;
  getenv(name: string, buf: Uint32Array): void;
  write_string(num: number, str: string): number;
  readFile(path: string, flags?: number, size?: number): Uint8Array;
  writeFile(
    path: string,
    u8: Uint8Array,
    flags?: number,
    mode?: number
  ): number;

  isFile(path: string): boolean;
  // conditionally defined props
  loader?: (specifier: string, resource: string) => string;
  sync_loader?: (specifier: string, resource: string) => string;
  binding_loader?: <T extends string>(name: T) => Library<T>;
}>;`

const runtime_type = () => `// TODO: autogenerate
interface Runtime {
  // validate with list from: lo eval 'console.log(\`"\${Object.getOwnPropertyNames(lo).join(\`":unknown;"\`)}":unknown;\`)'
  moduleCache: Map<string, ReturnType<Runtime['loadModule']>>;
  libCache: Map<string, object>;
  requireCache: Map<string, object>;
  start: number;
  errno: number;
  colors: Record<Uppercase<string>, string>;
  core: Core;
  libraries(): string[];
  builtins(): string[];
  assert(expression: any, message?: string | Function): any;
  cstr(str: string): Ptr<Uint8Array>;
  load<T extends NativeLibsKeys>(name: T): NativeLibXExport<T>;
  library<T extends string | number>(name: T): Library<T>;
  /**
   * Prints a string to the console
   * @param [str='a string'] The text to print.
   */
  print(str: string): void;
  exit(status: number): void;
  runMicroTasks(): void;
  hrtime(): number;
  nextTick(callback: Function): void;
  getAddress(buf: TypedArray): number;
  utf8Length(str: string): number;
  utf8EncodeInto(str: string, buf: TypedArray): number;
  utf8EncodeIntoAtOffset(str: string, buf: TypedArray, off: number): number;
  utf8_decode(address: number, len?: number): string;
  latin1Decode(address: number, len?: number): string;
  utf8Encode(str: string): Uint8Array;
  utf8Decode: Runtime['utf8_decode'];
  wrap<
    Handle extends Uint32Array,
    WrappedFnArgs extends unknown[],
    WrappedFnRet,
    State,
  >(
    handle: Handle,
    fn: ((...args: [...WrappedFnArgs]) => WrappedFnRet) & { state?: State },
    plen: number
  ): ((...args: WrappedFnArgs) => number) & { state?: State };
  addr(handle: TypedArray): number;
  version: RuntimeVersion;
  args: string[];
  argv: number;
  argc: number;
  workerSource: string;
  builtin(path: string): string;
  os(): OS;
  arch(): ARCH;
  getenv(str: string): string;
  evaluateModule<T extends object>(identifier: number): Promise<T>;
  loadModule(
    source: string,
    specifier: string
  ): {
    requests: string;
    isSourceTextModule: boolean;
    status: number;
    specifier: string;
    src: string;
    identity: number;
    scriptId: number;
    // js land extensions on returned value
    resource?: string;
    evaluated?: boolean;
    namespace?: object; // module namespace object
  };
  readMemory(dest: TypedArray, start: number, len: number): void;
  wrapMemory(start: number, size: number, free?: number): ArrayBuffer;
  unwrapMemory(buffer: ArrayBuffer): void;
  ptr<T extends TypedArray>(u8: T): Ptr<T>;
  register_callback(ptr: number, fn: Function): void;
  registerCallback: Runtime['register_callback'];
  setModuleCallbacks(
    on_module_load: Function,
    on_module_instantiate: Function
  ): void;

  utf8EncodeIntoPtr(str: string, ptr: number): number;
  runScript(source: string, path: string /* resource name */): void;
  pumpMessageLoop(): void;
  readMemoryAtOffset(
    u8: TypedArray,
    start: number,
    size: number,
    offset: number
  ): void;
  setFlags(str: string): void;
  getMeta: unknown;

  setenv: Core['setenv'];
  getcwd(): string;
  run_script: Runtime['runScript'];
  bindings: Runtime['libraries'];
  evaluate_module: Runtime['evaluateModule'];
  get_address: Runtime['getAddress'];
  get_meta: Runtime['getMeta'];
  latin1_decode: Runtime['latin1Decode'];
  lib_cache: Runtime['libCache'];
  load_module: Runtime['loadModule'];
  module_cache: Runtime['moduleCache'];
  next_tick: Runtime['nextTick'];
  pump_message_loop: Runtime['pumpMessageLoop'];
  read_memory: Runtime['readMemory'];
  read_memory_at_offset: Runtime['readMemoryAtOffset'];
  require_cache: Runtime['requireCache'];
  run_microtasks: Runtime['runMicroTasks'];
  set_flags: Runtime['setFlags'];
  set_module_callbacks: Runtime['setModuleCallbacks'];
  unwrap_memory: Runtime['unwrapMemory'];
  utf8_encode: Runtime['utf8Encode'];
  utf8_encode_into: Runtime['utf8EncodeInto'];
  utf8_encode_into_ptr: Runtime['utf8EncodeIntoPtr'];
  utf8_encode_into_at_offset: Runtime['utf8EncodeIntoAtOffset'];
  utf8_length: Runtime['utf8Length'];
  wrap_memory: Runtime['wrapMemory'];
}`

const native_lib_exports_types = () => `// ############ NativeLib Exports stuff ##############
// helpers
type Overwrite<T, U> = Omit<T, keyof U> & U;

// native lib helpers
type NativeLibsKeys = keyof NativeLibs;
type NativeLibX<T extends NativeLibsKeys> = NativeLibs[T];
type NativeLibXExport<T extends NativeLibsKeys> = Pick<NativeLibs, T>
`
